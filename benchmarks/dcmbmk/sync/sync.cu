#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "../common/repeat.h"

__global__ void ksync_test1 (unsigned int *ts, unsigned int* out, int p1, int p2, int its)
{
	unsigned int t1 = p1;
	unsigned int t2 = p2;
	unsigned int start_time = 0, stop_time = 0;
	unsigned int tid = blockIdx.x*blockDim.x + threadIdx.x;
	__shared__ volatile unsigned int count[32];

	unsigned int warpid = tid/32;
	
	count[tid%32] = 0;
	__syncthreads();

	if (tid < 16)
	{
		count[tid%32] = warpid + 1;
		start_time = clock();
		__syncthreads();
		stop_time = clock();
	}
	count[tid%32] = count[(tid+16)%32];

	out[0] = (t1 + t2); 
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2] = count[tid%32];
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2 +1] = stop_time - start_time;
}

__global__ void ksync_test2 (unsigned int *ts, unsigned int* out, int p1, int p2, int its)
{
	unsigned int t1 = p1;
	unsigned int t2 = p2;
	unsigned int start_time = 0, stop_time = 0;
	unsigned int tid = blockIdx.x*blockDim.x + threadIdx.x;
	__shared__ volatile unsigned int count[32];

	count[tid%32] = 0;
	__syncthreads();

	if (tid < 16)
	{
		count[tid%32] = tid+1;
		__syncthreads();
	}
	else 
	{
		//Taken path: Executed first under divergence.
		count[tid%32] = tid+1;
		__syncthreads();

		//This consumes count[0..15] generated by the first half
		count[tid%32] = count[(tid + 16)%32];	
	}

	out[0] = (t1 + t2); 
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2] = count[tid%32];
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2 +1] = stop_time - start_time;
}

__global__ void ksync_test3 (unsigned int *ts, unsigned int* out, int p1, int p2, int its)
{
	unsigned int t1 = p1;
	unsigned int t2 = p2;
	unsigned int start_time = 0, stop_time = 0;
	unsigned int tid = blockIdx.x*blockDim.x + threadIdx.x;
	unsigned int warpid = tid/32;
	__shared__ volatile unsigned int count[32];
	__shared__ volatile unsigned int count2[32];

	// WARNING: Recent versions (2.3) of nvcc have very aggressive in removing
	// syncthreads() calls. If there is no arithmetic after this syncthreads, the
	// second syncthreads within the then-clause (7 lines from here) gets removed.
	__syncthreads();
	count[tid%32]  = 0;
	count2[tid%32] = 1;

	if (warpid == 0)
	{
		__syncthreads();
		count[tid%32] = count2[tid%32]; 
	}
	else 
	{
		repeat128(t1+=t2;t2+=t1;)
		count2[tid%32] = tid;
	}

	out[0] = (t1 + t2); 
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2] = count[tid%32];
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2 +1] = stop_time - start_time;
}

/* THIS KERNEL HANGS. */
__global__ void ksync_test4 (unsigned int *ts, unsigned int* out, int p1, int p2, int its)
{
	unsigned int t1 = p1;
	unsigned int t2 = p2;
	unsigned int start_time = 0, stop_time = 0;
	unsigned int tid = blockIdx.x*blockDim.x + threadIdx.x;
	unsigned int warpid = tid/32;
	__shared__ volatile unsigned int sharedvar;

	__syncthreads();
	sharedvar = 0;

	if (warpid == 0)
	{
		__syncthreads();
		sharedvar = 1;
	}
	else 
	{
		while (sharedvar == 0);
	}

	out[0] = (t1 + t2); 
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2] = start_time; 
	ts[(blockIdx.x*blockDim.x + threadIdx.x)*2 +1] = stop_time;
}


void measure_sync()
{

	//const int kernel_ops = 256;
	unsigned int ts[1024];			// ts, output from kernel. Two elements used per thread.
	unsigned int *d_ts;
	unsigned int *d_out;			// Unused memory for storing output

	//run two warps
    	dim3 Db = dim3(32 * 2);
    	dim3 Dg = dim3(1,1,1);
	
	cudaDeviceProp deviceProp;
        cudaGetDeviceProperties(&deviceProp, 0);

	int warpsize = deviceProp.warpSize;

	// Allocate device array.
	cudaError_t errcode;
	if (cudaSuccess != (errcode = cudaMalloc((void**)&d_ts, sizeof(ts))))
	{
		printf ("cudaMalloc failed %s:%d\n", __FILE__, __LINE__);
		printf ("   %s\n", cudaGetErrorString(errcode));
		return;
	}
	if (cudaSuccess != cudaMalloc((void**)&d_out, 4))
	{
		printf ("cudaMalloc failed %s:%d\n", __FILE__, __LINE__);
		return;
	}

	cudaGetLastError();
    	printf ("Running __syncthreads() tests...\n");
	

	Db.x = warpsize * 1;
	printf("\nksync_test1: Kernel does not hang if only 16 threads of one warp calls syncthreads.");
	ksync_test1 <<<Dg, Db>>>(d_ts, d_out, 4, 6, 2);
	cudaThreadSynchronize();
	cudaMemcpy(ts, d_ts, sizeof(ts), cudaMemcpyDeviceToHost);

	printf("\n  count[0..15]:  {");
	for (int i = 0; i < 16-1; i++)
	{
		printf("%2d, ", ts[i*2]);
	}
	printf("%2d}", ts[15*2]);
	printf("\n  count[16..32]: {");
	for (int i = 16; i < 32-1; i++)
	{
		printf("%2d, ", ts[i*2]);
	}
	printf("%2d}\n", ts[31*2]);

	for (int i = 0; i < 2; i++)
	{
		printf("  warp: %2d, thread:%2d, \twait time:%6u\n", i/32, i%32, ts[2*i+1]);
	}

	if (cudaSuccess != cudaGetLastError())
		printf("failed.\n");


	Db.x = warpsize * 1;
	printf("\nksync_test2: Syncthreads within halves of one warp don't sync.");
	ksync_test2 <<<Dg, Db>>>(d_ts, d_out, 4, 6, 2);
	cudaThreadSynchronize();
	cudaMemcpy(ts, d_ts, sizeof(ts), cudaMemcpyDeviceToHost);

	printf("\n  count[0..15]:  {");
	for (int i = 0; i < 16-1; i++)
	{
		printf("%2d, ", ts[i*2]);
	}
	printf("%2d}", ts[15*2]);
	printf("\n  count[16..32]: {");
	for (int i = 16; i < 32-1; i++)
	{
		printf("%2d, ", ts[i*2]);
	}
	printf("%2d}\n", ts[31*2]);

	if (cudaSuccess != cudaGetLastError())
		printf("failed.\n");


	Db.x = warpsize * 2;
	printf("\nksync_test3: Only one of two warps calls syncthreads.");
	ksync_test3 <<<Dg, Db>>>(d_ts, d_out, 4, 6, 2);
	cudaThreadSynchronize();
	cudaMemcpy(ts, d_ts, sizeof(ts), cudaMemcpyDeviceToHost);

	printf("\n  count[0..32]:  {");
	for (int i = 0; i < warpsize-1; i++)
	{
		printf("%2d, ", ts[i*2]);
		if (i == warpsize/2-1)
		 	printf("\n\t\t");
	}
	printf("%2d}\n", ts[31*2]);
	
	
	if (cudaSuccess != cudaGetLastError())
		printf("failed.\n");



	printf("\n");

	cudaFree(d_ts);
	cudaFree(d_out);
}

// Function defined in sync2.cu
void measure_sync2();

int main()
{
	measure_sync();
	measure_sync2();
}
